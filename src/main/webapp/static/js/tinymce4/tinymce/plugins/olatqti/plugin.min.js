(function() {
    'use strict'; 
    
    var global$2 = tinymce.util.Tools.resolve('tinymce.PluginManager');

	var cachedTrans;
	var cachedCoreTrans;
	
	// Load the OLAT translator.
	function translator() {	
		if(cachedTrans) return cachedTrans;
		var mainWin = o_getMainWin();
		if (mainWin) {
			cachedTrans = jQuery(document).ooTranslator().getTranslator(mainWin.o_info.locale, 'org.olat.ims.qti21.ui.editor');
		} else {
			cachedTrans = {	translate : function(key) { return key; } }
		}
		return cachedTrans;
	}
	
	function coreTranslator() {	
		if(cachedCoreTrans) return cachedCoreTrans;
		var mainWin = o_getMainWin();
		if (mainWin) {
			cachedCoreTrans = jQuery(document).ooTranslator().getTranslator(mainWin.o_info.locale, 'org.olat.core');
		} else {
			cachedCoreTrans = {	translate : function(key) { return key; } }
		}
		return cachedCoreTrans;
	}
	
	function isHottextElement(element) {
		return element.hasAttribute('data-qti') && "hottext" === element.getAttribute('data-qti');
	}
	
	function isInlineChoiceElement(element) {
		return element.hasAttribute('data-qti') && "inlinechoiceinteraction" === element.getAttribute('data-qti');
	}
	
	function isTextEntryElement(element) {
		return element.hasAttribute('data-qti-gap-type') && "string" === element.getAttribute('data-qti-gap-type');
	}

	function isNumericalElement(element) {
		return element.hasAttribute('data-qti-gap-type') && "float" === element.getAttribute('data-qti-gap-type');
	}
	
	function s4() {
		return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	}
	
	function guid() {
		return s4() + s4() + s4() + s4() + s4() + s4() + s4();
	}
    
    var register = function (editor, url) {

		var lastSelectedGap;
		var lastSelectedHottext;
		var lastSelectedInlineChoice;
		var lastResponseIdentifierCounter = 0;

		function showTextDialog(e) {
			showDialog(e, "string")
		}
		
		function showNumericalDialog(e) {
			showDialog(e, "float")
		}

		function showDialog(e, gapType) {
			var ffxhrevent = editor.getParam("ffxhrevent");
			
			if(typeof lastSelectedGap != 'undefined') {
				var textEntryEl = jQuery(lastSelectedGap).closest("span[data-qti='textentryinteraction']");
				var responseIdentifier = textEntryEl.attr('data-qti-response-identifier');
				var solution = jQuery(textEntryEl).children().html();
				var emptySolution = (solution == "" || solution == "&nbsp;" ? "true" : "false");
				o_ffXHREvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2, false, false, false,
						'_csrf', ffxhrevent.csrf, 'cmd', 'gapentry', 'responseIdentifier', responseIdentifier, 'selectedText', solution, 'emptySolution', emptySolution, 'newEntry', false);
			} else {
				var counter = 1;
				var newSelectedText = editor.selection.getContent({format: 'text'})
				
				tinymce.each(editor.dom.select("span[data-qti]"), function(node) {
					var identifier = jQuery(node).attr('data-qti-response-identifier');
					if(identifier.lastIndexOf("RESPONSE_", 0) == 0) {
						var id = parseInt(identifier.substring(9, identifier.length));
						if(id > counter) {
							counter = id;
						}	
					}
			    });
			    
			    var nextCounter = (counter + 1);
			    if(nextCounter < lastResponseIdentifierCounter) {
			    	nextCounter = lastResponseIdentifierCounter + 1;
			    	lastResponseIdentifierCounter = nextCounter;
			    } else if(nextCounter > lastResponseIdentifierCounter) {
					lastResponseIdentifierCounter = nextCounter;
			    }
				
				var responseIdentifier = "RESPONSE_" + nextCounter;
				if(typeof newSelectedText === "undefined" || newSelectedText.length == 0) {
					if(gapType === "float") {
						newSelectedText = "42.0";
					} else {
						newSelectedText = "gap";
					}
				}
				
				var placeholder = createTextEntryPlaceholder(responseIdentifier, newSelectedText, 'textentryinteraction', gapType);
				var holderHtml = new tinymce.html.Serializer().serialize(placeholder);
				editor.insertContent(holderHtml);
			
				o_ffXHREvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2, false, false, false,
						'_csrf', ffxhrevent.csrf, 'cmd', 'gapentry', 'responseIdentifier', responseIdentifier, 'newEntry', true, 'selectedText', newSelectedText, 'gapType', gapType);
			}
			editor.setDirty(true);
		}
			
		function createHottext(e) {
			var responseIdentifier;
			if(typeof lastSelectedHottext != 'undefined') {
				responseIdentifier = jQuery(lastSelectedHottext).data('data-identifier')
			} else {
				var counter = 1;
				var selectedText = editor.selection.getContent({format: 'text'});
				var preSelect = false;
				if(selectedText == null || selectedText.length == 0) {
					selectedText = "text";
					preSelect = true;
				}

				var identifier = "ht" + guid();
				var placeholder = createHottextPlaceholder(identifier, selectedText, false, 'hottext');
				var holderHtml = new tinymce.html.Serializer().serialize(placeholder);
				editor.insertContent(holderHtml + " ");
				
				if(preSelect) {
					var selectedNode = editor.dom.select("span[data-qti-identifier=" + identifier + "] span[contenteditable=true]");
					editor.selection.select(selectedNode[0], true);
				}
				
				jQuery("span.hottext[data-qti-identifier='" + identifier + "'] a", editor.getBody()).each(function(index, el) {
					correctHottextEvent(el);
				});
			}
		}
		
		function showInlineChoiceDialog(e) {
			var ffxhrevent = editor.getParam("ffxhrevent");
			
			if(typeof lastSelectedInlineChoice != 'undefined') {
				var inlineChoiceEl = jQuery(lastSelectedInlineChoice).closest("span[data-qti='inlinechoiceinteraction']");
				var responseIdentifier = inlineChoiceEl.attr('data-qti-response-identifier');
				o_ffXHREvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2, false, false, true,
						'_csrf', ffxhrevent.csrf, 'qcmd', 'inlinechoiceinteraction', 'responseIdentifier', responseIdentifier, 'newEntry', false);
			} else {
				var nextCounter = nextResponseNumber();
				var responseIdentifier = "inline" + guid();
				var emptySelection = false;
				var selectedText = editor.selection.getContent({format: 'text'});
				if(typeof selectedText === "undefined" || selectedText.length == 0) {
					selectedText = "";
					emptySelection = true;
				}
				
				var placeholder = createInlineChoicePlaceholder(responseIdentifier, selectedText, 'inlinechoiceinteraction');
				var holderHtml = new tinymce.html.Serializer().serialize(placeholder);
				editor.insertContent(holderHtml);
			
				o_ffXHREvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2, false, false, true,
						'_csrf', ffxhrevent.csrf, 'qcmd', 'inlinechoiceinteraction', 'responseIdentifier', responseIdentifier, 'newEntry', true, 'selectedText', selectedText, 'emptySelection', emptySelection);
			}
			editor.setDirty(true);
		}
		
		function createInlineChoice(e) {
			var responseIdentifier;
			if(typeof lastSelectedInlineChoice != 'undefined') {
				responseIdentifier = jQuery(lastSelectedInlineChoice).data('data-qti-response-identifier')
			} else {
				var counter = 1;
				var selectedText = editor.selection.getContent({format: 'text'});
				var preSelect = false;
				if(selectedText == null || selectedText.length == 0) {
					selectedText = "text";
					preSelect = true;
				}

				var identifier = "inline" + guid();
				var placeholder = createInlineChoicePlaceholder(identifier, selectedText, 'inlinechoiceinteraction');
				var holderHtml = new tinymce.html.Serializer().serialize(placeholder);
				editor.insertContent(holderHtml);
				
				if(preSelect) {
					var selectedNode = editor.dom.select("span[data-qti-identifier=" + identifier + "] span[contenteditable=true]");
					editor.selection.select(selectedNode[0], true);
				}
			}
		}
		
		function nextResponseNumber() {
			var counter = 1;

			tinymce.each(editor.dom.select("span[data-qti]"), function(node) {
				var identifier = jQuery(node).attr('data-qti-response-identifier');
				if(identifier.lastIndexOf("RESPONSE_", 0) == 0) {
					var id = parseInt(identifier.substring(9, identifier.length));
					if(id > counter) {
						counter = id;
					}	
				}
		    });
		    
		    var nextCounter = (counter + 1);
		    if(nextCounter < lastResponseIdentifierCounter) {
		    	nextCounter = lastResponseIdentifierCounter + 1;
		    	lastResponseIdentifierCounter = nextCounter;
		    } else if(nextCounter > lastResponseIdentifierCounter) {
				lastResponseIdentifierCounter = nextCounter;
		    }
		    
			return nextCounter;
		}

		editor.ui.registry.addToggleButton('olatqtifibtext', {
			tooltip : translator().translate('new.fib'),
			icon : 'gaptext',
			onAction: showTextDialog,
			onSetup: function (buttonApi) {
				var selection = editor.selection;
				buttonApi.setActive(isTextEntryElement(selection.getNode()));
				return selection.selectorChangedWithUnbind('span[data-qti-gap-type=string]', buttonApi.setActive).unbind;
			}
		});
		
		editor.ui.registry.addToggleButton('olatqtifibnumerical', {
			tooltip : translator().translate('new.fib.numerical'),
			icon : 'gapnumerical',
			onAction: showNumericalDialog,
			onSetup: function (buttonApi) {
				var selection = editor.selection;
				buttonApi.setActive(isNumericalElement(selection.getNode()));
				return selection.selectorChangedWithUnbind('span[data-qti-gap-type=float]', buttonApi.setActive).unbind;
			}
		});

		editor.ui.registry.addToggleButton('olatqtihottext', {
			tooltip : translator().translate('new.hottext'),
			icon : 'hottext',
			onAction: createHottext,
			onSetup: function (buttonApi) {
				var selection = editor.selection;
				buttonApi.setActive(isHottextElement(selection.getNode()));
				return selection.selectorChangedWithUnbind('span[data-qti]', buttonApi.setActive).unbind;
			}
		});
		
		editor.ui.registry.addToggleButton('olatqtiinlinechoice', {
			tooltip : translator().translate('new.inlinechoice'),
			icon : 'inlinechoice',
			onAction: showInlineChoiceDialog,
			onSetup: function (buttonApi) {
				var selection = editor.selection;
				buttonApi.setActive(isInlineChoiceElement(selection.getNode()));
				return selection.selectorChangedWithUnbind('span[data-qti]', buttonApi.setActive).unbind;
			}
		});	
		
		editor.ui.registry.addMenuItem('olatqtifibtext', {
			text : translator().translate('new.fib'),
			icon : 'gapnumerical',
			onAction: showNumericalDialog
		});
		
		editor.ui.registry.addMenuItem('olatqtifibnumerical', {
			text : translator().translate('new.fib.numerical'),
			icon : 'gaptext',
			onAction: showTextDialog
		});
		
		editor.ui.registry.addMenuItem('olatqtihottext', {
			text : translator().translate('new.hottext'),
			icon : 'hottext',
			onAction: createHottext
		});
		
		editor.ui.registry.addMenuItem('olatqtiinlinechoice', {
			text : translator().translate('new.inlinechoice'),
			icon : 'inlinechoice',
			onAction: createInlineChoice
		});
			
		editor.on('NodeChange', function(e) {
			if (lastSelectedGap && lastSelectedGap.id != e.element.src) {
				lastSelectedGap = undefined;
			}
			if (lastSelectedHottext && lastSelectedHottext.id != e.element.src) {
				lastSelectedHottext = undefined;
			}
			
			if (editor.dom.is(e.element, 'span[data-qti=textentryinteraction]')) {
				lastSelectedGap = e.element;
			} else if (jQuery(e.element).parent("span[data-qti='textentryinteraction']").length > 0) {
				lastSelectedGap = e.element;
			}
			
			if (editor.dom.is(e.element, 'span[data-qti=inlinechoiceinteraction]')) {
				lastSelectedInlineChoice = e.element;
			}
			
			if (jQuery(e.element).parent('span.hottext').length > 0) {
				lastSelectedHottext = e.element;
			}
			
			jQuery(e.element).parent("span[data-qti-gap-type=float]").each(function(index, el) {
				if(jQuery(e.element).prop("tagName").toLowerCase() == "span") {
					var solution = jQuery(e.element).text();
					if(!jQuery.isNumeric(solution)) {
						jQuery(el).addClass('error');
					} else {
						jQuery(el).removeClass('error');
					}
				}
			});
			
			jQuery("span.hottext[data-copy='needlistener']", e.element).each(function(index, el) {
				if(jQuery("a.o_check", el).length == 0) {
					var checked = jQuery(el).attr('data-qti-checked');
					jQuery(el).prepend("<a class='o_check " + ("true" == checked ? "checked" : "") + "' contenteditable='false'><i contenteditable='false'> </i></a>");
				}
				
				//remove the placeholder for Firefox
				if(jQuery("span[contenteditable='true']", el).text() == "x-y-x" && jQuery(el).attr('data-qti-empty') == "true") {
					jQuery("span[contenteditable='true']", el).text("");
					jQuery(el).attr('data-qti-empty', 'false');
				}

				jQuery("a.o_check", jQuery(el)).each(function(aIndex, aEl) {
					var ev = jQuery._data(aEl, 'events');
					if(ev && ev.click) {
						/* double check */ 
					} else {
						correctHottextEvent(aEl);
						//confirm by sending the setting to the server
						if(jQuery(aEl).hasClass('checked')) {
							var ffxhrevent = editor.getParam("ffxhrevent");
							var identifier = jQuery(el).data('qti-identifier');
							o_ffXHRNFEvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2,
								'_csrf', ffxhrevent.csrf, 'cmd', 'hottext', 'identifier', identifier, 'correct', 'true');
						}
					}
				});
			});
			
			jQuery("span.textentryinteraction[data-copy='needlistener']", e.element).each(function(index, el) {
				if(jQuery("a.o_ops", el).length == 0) {
					jQuery(el).append("<a class='o_ops' contenteditable='false'><i contenteditable='false'> </i></a>");
				}
				
				//remove the placeholder for Firefox
				if(jQuery("span[contenteditable='true']", el).text() == "x-y-x" && jQuery(el).attr('data-qti-empty') == "true") {
					jQuery("span[contenteditable='true']", el).text("");
					jQuery(el).attr('data-qti-empty', 'false');
				}
				
				jQuery("a.o_ops", jQuery(el)).each(function(aIndex, aEl) {
					var ev = jQuery._data(aEl, 'events');
					if(ev && ev.click) {
						//double check 
					} else {
						textEntryEvent(el);
					}
				});
			});
		});
			
		function createTextEntryPlaceholder(responseIdentifier, content, interaction, gapType) {
			var placeholder = new tinymce.html.Node('span', 1);
			placeholder.attr({
				"id": responseIdentifier,
				"draggable": "false",
				"data-qti": interaction,
				"data-qti-response-identifier": responseIdentifier,
				"data-qti-solution" : content,
				"data-qti-gap-type": gapType,
				"data-mce-placeholder": "",
				"data-textentryinteraction": "empty",
				"class": interaction,
				"contenteditable": "false"
			});
			
			var readonly = editor.getParam("readonly");
            var editable = readonly == "1" ? "false" : "true";
			var contentholder = new tinymce.html.Node('span', 1);
            contentholder.attr({ "contenteditable": editable });
            var textNode = new tinymce.html.Node('#text', 3);
            textNode.raw = true;
            
            var escapedContent = jQuery("<div>").text(content).html();
            textNode.value = escapedContent;
            contentholder.append(textNode);
            placeholder.append(contentholder);

            var aHolder = new tinymce.html.Node('a', 1);
            aHolder.attr({ "contenteditable": "false", "class": "o_ops" });
            var aTextHolder = new tinymce.html.Node('i', 1);
            aTextHolder.attr({ "contenteditable": "false" });
            var aTextNode = new tinymce.html.Node('#text', 3);
            aTextNode.raw = true;
            aTextNode.value = '&nbsp;';
            aTextHolder.append(aTextNode);
            aHolder.append(aTextHolder);
            placeholder.append(aHolder);
			return placeholder;
		}
			
		function createHottextPlaceholder(identifier, content, correct, interaction) {
			var placeholder = new tinymce.html.Node('span', 1);
			placeholder.attr({
				"data-qti": interaction,
				"data-qti-identifier": identifier,
				"data-qti-checked": (correct ? "true": "false"),
				"class": interaction,
				"draggable": "false",
				"contenteditable": "false"
			});

			var readonly = editor.getParam("readonly");
            var editable = readonly == "1" ? "false" : "true";
            
            var checkHolder = new tinymce.html.Node('a', 1);
            checkHolder.attr({
				"contenteditable": "false",
				"class": "o_check " + (correct ? "checked": "")
            });
            var aTextHolder = new tinymce.html.Node('i', 1);
            aTextHolder.attr({ "contenteditable": "false" });
            var aTextNode = new tinymce.html.Node('#text', 3);
            aTextNode.raw = true;
            aTextNode.value = '&nbsp;';
            aTextHolder.append(aTextNode);
            checkHolder.append(aTextHolder);
            placeholder.append(checkHolder);

            var contentholder = new tinymce.html.Node('span', 1);
            contentholder.attr({ "contenteditable": editable });
            if(typeof content === "string") {
            	var textNode = new tinymce.html.Node('#text', 3);
            	textNode.raw = true;
            	textNode.value = content;
            	contentholder.append(textNode);
            } else {
            	var node, collection = [];
                for (node = content.firstChild; node; node = node.walk()) {
                	if(node.parent == content) {
                		collection.push(node);
                	}
					if(node == content.lastChild) {
						break;
					}
                }
                for(var i=0; i<collection.length; i++) {
	            	contentholder.append(collection[i]);
                }
            }
            placeholder.append(contentholder);
			return placeholder;
		}
		
		function createInlineChoicePlaceholder(responseIdentifier, content, interaction) {
			var placeholder = new tinymce.html.Node('span', 1);
			placeholder.attr({
				"id": responseIdentifier,
				"data-qti": interaction,
				"data-qti-response-identifier": responseIdentifier,
				"data-qti-solution" : content,
				"data-mce-placeholder": "",
				"class": interaction,
				"draggable": "false",
				"contenteditable": "false"
			});
			
			var contentholder = new tinymce.html.Node('span', 1);
            contentholder.attr({ "contenteditable": "false", "draggable": "false" });
            var textNode = new tinymce.html.Node('#text', 3);
            textNode.raw = true;
           
            var escapedContent = jQuery("<div>").text(content).html();
            textNode.value = escapedContent;
            contentholder.append(textNode);
            placeholder.append(contentholder);

            var aHolder = new tinymce.html.Node('a', 1);
            aHolder.attr({ "contenteditable": "false", "class": "o_ops", "draggable": "false" });
            var aTextHolder = new tinymce.html.Node('i', 1);
            aTextHolder.attr({ "contenteditable": "false" });
            var aTextNode = new tinymce.html.Node('#text', 3);
            aTextNode.raw = true;
            aTextNode.value = '&nbsp;';
            aTextHolder.append(aTextNode);
            aHolder.append(aTextHolder);
            placeholder.append(aHolder);
			return placeholder;
		}
			
		function correctHottextEvent(linkEl) {
			jQuery(linkEl).click(function() {
				var ffxhrevent = editor.getParam("ffxhrevent");
				var jLinkEl = jQuery(linkEl);
				var identifier = jLinkEl.parent("span.hottext").data('qti-identifier');
				o_ffXHRNFEvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2,
						'_csrf', ffxhrevent.csrf, 'cmd', 'hottext', 'identifier', identifier, 'correct', jLinkEl.hasClass('checked') ? "false" : "true");
				if(jLinkEl.hasClass('checked')) {
					jLinkEl.removeClass('checked');
					jLinkEl.parent("span.hottext").attr('data-qti-checked', "false");
				} else {
					jLinkEl.addClass('checked');
					jLinkEl.parent("span.hottext").attr('data-qti-checked', "true");
				}
				editor.setDirty(true);
			});
		}
			
		function textEntryEvent(textEntryEl) {
			jQuery("a.o_ops", textEntryEl).click(function() {
				var ffxhrevent = editor.getParam("ffxhrevent");
				var responseIdentifier = jQuery(textEntryEl).attr('data-qti-response-identifier');
				var solution = jQuery(textEntryEl).children().html();
				var emptySolution = (solution == "" || solution == "&nbsp;" ? "true" : "false");
				o_ffXHREvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2, false, false, false,
						'_csrf', ffxhrevent.csrf, 'cmd', 'gapentry', 'responseIdentifier', responseIdentifier, 'selectedText', solution, 'emptySolution', emptySolution);
				editor.setDirty(true);
			});
		}
		
		function inlineChoiceInteractionEvent(el) {
			jQuery("a.o_ops", el).click(function() {
				var ffxhrevent = editor.getParam("ffxhrevent");
				var responseIdentifier = jQuery(el).attr('data-qti-response-identifier');
				var solution = jQuery(el).children().html();
				var emptySolution = (solution == "" || solution == "&nbsp;" ? "true" : "false");
				o_ffXHREvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2, false, false, true,
						'_csrf', ffxhrevent.csrf, 'qcmd', 'inlinechoiceinteraction', 'responseIdentifier', responseIdentifier, 'selectedText', solution, 'emptySolution', emptySolution);
				editor.setDirty(true);
			});
		}
			
		function getTextContent(node) {
			var content = '';
			var walker = new tinymce.dom.TreeWalker(node);
			var textNode;
			while ((textNode = walker.next())) {
				if (textNode.type == 3) {
					if(content.length > 0) content += ' ';
					content += textNode.value;
				} else if(textNode.nodeType == 3) {
					if(content.length > 0) content += ' ';
					content += textNode.nodeValue;
				}
			}
			return content;
		}
			
		function replaceTextContent(content) {
		
			var replace = false;
			var wrappedContent = '<div id="' + guid() + '">' + content + '</div>';
			var htmlContent = jQuery(wrappedContent);

			jQuery(htmlContent).find("span[data-qti='hottext']").each(function(index, el) {
				var hotId = 'ht' + guid();
				jQuery(el).attr('data-qti-identifier', hotId);
				jQuery(el).attr('data-copy', 'needlistener');
				jQuery(el).attr('data-copy-empty', 'false');
				
				var empty = jQuery("span[contenteditable='true']", el).text();
				if(empty == null || empty.length == 0) {
					jQuery("span[contenteditable='true']", el).text("x-y-x");
					jQuery(el).attr('data-copy-empty', 'true');
				}
				replace = true;
			});
			
			jQuery(htmlContent).find("span[data-qti='textentryinteraction']").each(function(index, el) {
				var entryId = 'te' + guid();
				jQuery(el).attr('data-qti-response-identifier', entryId);
				jQuery(el).attr('data-copy', 'needlistener');
				jQuery(el).attr('data-copy-empty', 'false');
				
				var gapType = jQuery(el).attr("data-qti-gap-type");
				var solution = jQuery(el).attr("data-qti-solution");
				var ffxhrevent = editor.getParam("ffxhrevent");
				o_ffXHRNFEvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2,
						'_csrf', ffxhrevent.csrf, 'cmd', 'copy-gapentry', 'responseIdentifier', entryId, 'newEntry', true, 'selectedText', solution, 'gapType', gapType);
				//add it because tiny delete it
				jQuery("a.o_ops", el).append(jQuery("<i class='visible'>&nbsp;</i>"));
				
				var empty = jQuery("span[contenteditable='true']", el).text();
				if(empty == null || empty.length == 0) {
					jQuery("span[contenteditable='true']", el).text("x-y-x");
					jQuery(el).attr('data-copy-empty', 'true');
				}
				
				replace = true;
			});
			
			// new internal copy/paste
			jQuery(htmlContent).find("hottext").each(function(index, el) {
				var hotId = 'ht' + guid();
				jQuery(el).attr('identifier', hotId);
				replace = true;
			});
			
			jQuery(htmlContent).find("textentryinteraction").each(function(index, el) {
				var entryId = 'te' + guid();
				jQuery(el).attr('responseidentifier', entryId);
				
				var gapType = jQuery(el).attr("data-qti-gap-type");
				var solution = jQuery(el).attr("data-qti-solution");
				var ffxhrevent = editor.getParam("ffxhrevent");
				
				o_ffXHRNFEvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2,
						'_csrf', ffxhrevent.csrf, 'cmd', 'copy-gapentry', 'responseIdentifier', entryId, 'newEntry', true, 'selectedText', solution, 'gapType', gapType);
				replace = true;
			});
			
			jQuery(htmlContent).find("inlinechoiceinteraction").each(function(index, el) {
				var sourceResponseIdentifier = jQuery(el).attr('responseidentifier');
				var entryId = 'te' + guid();
				jQuery(el).attr('responseidentifier', entryId);
				var ffxhrevent = editor.getParam("ffxhrevent");
				
				o_ffXHRNFEvent(ffxhrevent.formNam, ffxhrevent.dispIdField, ffxhrevent.dispId, ffxhrevent.eventIdField, 2,
						'_csrf', ffxhrevent.csrf, 'cmd', 'copy-inlinechoice', 'responseIdentifier', entryId, 'newEntry', true, 'sourceResponseIdentifier', sourceResponseIdentifier);
				replace = true;
			});
			
			var replacement = new Object();
			replacement.replace = replace;
			replacement.htmlContent = htmlContent;
			return replacement;
		}
			
		editor.addCommand('qtiUpdateTextEntry', function (ui, value) {
			var responseIdentifier = value['responseIdentifier'];
			var solution = value['data-qti-solution'];
			jQuery("span[data-qti-response-identifier='" + responseIdentifier+ "']>span", editor.getBody()).each(function(index, el) {
				jQuery(el).text(solution);
			});
			
			jQuery("span[data-qti-response-identifier='" + responseIdentifier+ "']", editor.getBody()).each(function(index, el) {
				textEntryEvent(jQuery(el));
			});
			editor.execCommand('mceRepaint');
			editor.setDirty(true);
		});
		
		editor.addCommand('qtiCancelTextEntry', function (ui, value) {
			editor.setDirty(true);
		});
		
		editor.addCommand('qtiUpdateInlineChoice', function (ui, value) {
			var responseIdentifier = value['responseIdentifier'];
			var solution = value['data-qti-solution'];
			var correctResponse = value['data-qti-correct-response'];
			if(correctResponse === "false") {
				solution = translator().translate('warning.correct.answer.short');
			} else if(typeof solution === "undefined" || solution == null || (solution === "" && correctResponse === "true")) {
				solution = "";
			}
						
			var replaced = false;
			jQuery("span[data-qti-response-identifier='" + responseIdentifier+ "']>span", editor.getBody()).each(function(index, el) {
				replaced = true;
				jQuery(el).text(solution);
			});
			
			if(!replaced) {
				jQuery("span[data-qti-response-identifier='" + responseIdentifier+ "']", editor.getBody()).each(function(index, el) {
					jQuery(el).prepend("<span contenteditable='false'>" + solution + "</span>");
				});
			}
			
			jQuery("span[data-qti-response-identifier='" + responseIdentifier+ "']", editor.getBody()).each(function(index, el) {
				inlineChoiceInteractionEvent(jQuery(el));
			});
			editor.execCommand('mceRepaint');
			editor.setDirty(true);
		});
		
		editor.addCommand('qtiCancelInlineChoice', function (ui, value) {
			editor.setDirty(true);
		});
		
		editor.on('dragstart', function(e) {
			try {
				if(e.target.draggable === false) {
					e.preventDefault();
					e.stopPropagation();
				}
			} catch(e) {
				if(console) console.log(e);
			}
		});

		// Load Content CSS upon initialization
		editor.on('init', function() {
			if (editor.settings.content_css !== false) {
				editor.dom.loadCSS(url + "/css/content.css");
			}
			
			jQuery(".textentryinteraction", editor.getBody()).each(function(index, el) {
				textEntryEvent(el);
			});
			
			jQuery("span.hottext a.o_check", editor.getBody()).each(function(index, el) {
				correctHottextEvent(el);
			});
			
			jQuery(".inlinechoiceinteraction", editor.getBody()).each(function(index, el) {
				inlineChoiceInteractionEvent(el);
			});
		});
			
		/**
		 * Replace on load the special XML tags of QTI to some placeholders
		 * useable by TinyMCE.
		 * 
		 */
		editor.on('preInit', function() {
			editor.parser.addNodeFilter('textentryinteraction,hottext,inlinechoiceinteraction', function(nodes) {
				var i = nodes.length;
				while (i--) {
					var node = nodes[i];
					if (node.name == 'textentryinteraction') {
						var responseIdentifier = node.attr('responseidentifier');
						if(responseIdentifier.lastIndexOf("RESPONSE_", 0) == 0) {
							var id = parseInt(responseIdentifier.substring(9, responseIdentifier.length));
							if(id > lastResponseIdentifierCounter) {
								lastResponseIdentifierCounter = id;
							}
						}

						var solution = node.attr('data-qti-solution');
						if(typeof solution === "undefined") {
							solution = "&nbsp;";
						}
						var gapType = node.attr('data-qti-gap-type');
						if(typeof gapType === "undefined") {
							gapType = "string";
						}
						var placeHolder = createTextEntryPlaceholder(responseIdentifier, solution, 'textentryinteraction', gapType);
						node.replace(placeHolder);
					} else if (node.name == 'hottext') {
						var identifier = node.attr('identifier');
						var correctHottexts = editor.getParam("correctHottexts");
						var correct = jQuery.inArray(identifier, correctHottexts) >= 0;
						var content = node;
						var placeHolder = createHottextPlaceholder(identifier, content, correct, 'hottext', 'hottext');
						node.replace(placeHolder);
					} else if (node.name == 'inlinechoiceinteraction') {
						var responseIdentifier = node.attr('responseidentifier');
						var solution = node.attr('data-qti-solution');
						var correctResponses = editor.getParam("correctResponses");
						var missingCorrectResponses = editor.getParam("missingCorrectResponses");
						var missing = jQuery.inArray(responseIdentifier, missingCorrectResponses) >= 0;
						
						if(missing) {
							solution = translator().translate('warning.correct.answer.short');
						} else if(correctResponses != null) {
							for(var j=correctResponses.length; j-->0; ) {
								if(correctResponses[j].id === responseIdentifier) {
									solution = correctResponses[j].value;
								}
							}
						}
						var content = node;
						var placeHolder = createInlineChoicePlaceholder(responseIdentifier, solution, 'inlinechoiceinteraction');
						node.replace(placeHolder);
					}
				}
			});
		});
			
		/** 
         * This event is catch to convert the content of the editor in something useable for
         * OpenOlat, e.g. replace all placeholders with real HTML/XML QTI code.
         */
		editor.on('PreProcess', function(e) {
			jQuery("span[data-qti='textentryinteraction']", e.node).each(function(idx, node) {
				var jNode = jQuery(node);
				var identifier = jNode.attr('data-qti-response-identifier');
				var solution = jNode.children('span').text();
				var gapType = jNode.attr('data-qti-gap-type');
				var textNode = editor.dom.create("textEntryInteraction", {
					responseIdentifier: identifier,
					"data-qti-gap-type": gapType,
					"data-qti-solution": solution,
					"data-qti-solution-empty": (solution == "" || solution == "&nbsp;" ? "true" : "false")
				});

				var alone = node.previousSibling == null && (node.nextSibling == null
					|| (node.nextSibling != null  && node.nextSibling.textContent != null
							&& node.nextSibling.textContent.length == 1 && node.nextSibling.textContent.charCodeAt(0) == 65279)
					|| jQuery(node.nextSibling).attr("type") == "_moz"
					|| jQuery(node.nextSibling).attr("data-mce-bogus") == "1");
				editor.dom.replace(textNode, node, false);
				if(alone) {
					jQuery(textNode).after(String.fromCharCode(160));
				}
		    });
			
			jQuery("span[data-qti='hottext']", e.node).each(function(idx, node) {
				var identifier = jQuery(node).data('qti-identifier');
				var hottextNode = editor.dom.create("hottext", { identifier: identifier });
				var hottextContent = jQuery('span[contenteditable="true"]', node);
				jQuery(hottextNode).append(hottextContent.contents());
				editor.dom.replace(hottextNode, node, false);
		    });
		    
		    jQuery("span[data-qti='inlinechoiceinteraction']", e.node).each(function(idx, node) {
				var jNode = jQuery(node);
				var responseIdentifier = jNode.data('qti-response-identifier');
				var solution = jNode.children('span').text();
				var inlineChoiceNode = editor.dom.create("inlinechoiceinteraction", {
					responseIdentifier: responseIdentifier,
					"data-qti-solution": solution,
					"data-qti-solution-empty": (solution == "" || solution == "&nbsp;" ? "true" : "false"),
					shuffle: "true"
				});
				editor.dom.replace(inlineChoiceNode, node, false);
		    });
		});
			
		editor.on('newcell', function (e) {
			var replacement = replaceTextContent(e.node.innerHTML);
			if(replacement.replace) {
				e.node.innerHTML = jQuery(replacement.htmlContent).html();
			}
		});
		
		editor.on('PastePreProcess', function (e, param) {
			var selectedNode = editor.selection.getNode();
			if(selectedNode != null &&
					(jQuery(selectedNode).parent("span.hottext").length > 0
						|| jQuery(selectedNode).parent("span.textentryinteraction").length > 0
						|| jQuery(selectedNode).parent("span.inlinechoiceinteraction").length > 0)) {
				// paste in an hottext or a textEntryInteraction -> only text
				var wrappedContent = '<div id="' + guid() + '">' + e.content + '</div>';
				var htmlContent = jQuery(wrappedContent);
				e.content = jQuery(htmlContent).text();
				return;
			}
			
			// replace and create new id
			var replacement = replaceTextContent(e.content);
			if(replacement.replace) {
				e.content = jQuery(replacement.htmlContent).html();
			}
		});

	};
	
	function Plugin () {
		global$2.add('olatqti', function (editor, url) {
			register(editor, url);
		});
    }

    Plugin();
})();