/**
 * <a href="http://www.openolat.org">
 * OpenOLAT - Online Learning and Training</a><br>
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License"); <br>
 * you may not use this file except in compliance with the License.<br>
 * You may obtain a copy of the License at the
 * <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache homepage</a>
 * <p>
 * Unless required by applicable law or agreed to in writing,<br>
 * software distributed under the License is distributed on an "AS IS" BASIS, <br>
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>
 * See the License for the specific language governing permissions and <br>
 * limitations under the License.
 * <p>
 * Initial code contributed and copyrighted by<br>
 * frentix GmbH, http://www.frentix.com
 * <p>
 */
package org.olat.ims.qti21.model.xml.interactions;

import static org.olat.ims.qti21.model.xml.AssessmentItemFactory.appendDefaultItemBody;
import static org.olat.ims.qti21.model.xml.AssessmentItemFactory.appendDefaultOutcomeDeclarations;
import static org.olat.ims.qti21.model.xml.AssessmentItemFactory.appendInlineChoice;
import static org.olat.ims.qti21.model.xml.AssessmentItemFactory.appendInlineChoiceInteraction;
import static org.olat.ims.qti21.model.xml.AssessmentItemFactory.appendMapping;
import static org.olat.ims.qti21.model.xml.AssessmentItemFactory.createInlineChoiceResponseDeclaration;
import static org.olat.ims.qti21.model.xml.AssessmentItemFactory.createResponseProcessing;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.logging.log4j.Logger;
import org.olat.core.gui.render.StringOutput;
import org.olat.core.logging.Tracing;
import org.olat.core.util.CodeHelper;
import org.olat.core.util.StringHelper;
import org.olat.ims.qti21.QTI21Constants;
import org.olat.ims.qti21.model.IdentifierGenerator;
import org.olat.ims.qti21.model.QTI21QuestionType;
import org.olat.ims.qti21.model.xml.AssessmentItemBuilder;
import org.olat.ims.qti21.model.xml.AssessmentItemFactory;
import org.olat.ims.qti21.model.xml.QtiNodesExtractor;
import org.olat.ims.qti21.model.xml.interactions.SimpleChoiceAssessmentItemBuilder.ScoreEvaluation;

import uk.ac.ed.ph.jqtiplus.attribute.ForeignAttribute;
import uk.ac.ed.ph.jqtiplus.node.content.ItemBody;
import uk.ac.ed.ph.jqtiplus.node.content.basic.Block;
import uk.ac.ed.ph.jqtiplus.node.content.basic.TextRun;
import uk.ac.ed.ph.jqtiplus.node.content.variable.TextOrVariable;
import uk.ac.ed.ph.jqtiplus.node.expression.general.BaseValue;
import uk.ac.ed.ph.jqtiplus.node.expression.general.Correct;
import uk.ac.ed.ph.jqtiplus.node.expression.general.MapResponse;
import uk.ac.ed.ph.jqtiplus.node.expression.general.Variable;
import uk.ac.ed.ph.jqtiplus.node.expression.operator.And;
import uk.ac.ed.ph.jqtiplus.node.expression.operator.Match;
import uk.ac.ed.ph.jqtiplus.node.expression.operator.Sum;
import uk.ac.ed.ph.jqtiplus.node.item.AssessmentItem;
import uk.ac.ed.ph.jqtiplus.node.item.CorrectResponse;
import uk.ac.ed.ph.jqtiplus.node.item.interaction.InlineChoiceInteraction;
import uk.ac.ed.ph.jqtiplus.node.item.interaction.Interaction;
import uk.ac.ed.ph.jqtiplus.node.item.interaction.choice.InlineChoice;
import uk.ac.ed.ph.jqtiplus.node.item.response.declaration.MapEntry;
import uk.ac.ed.ph.jqtiplus.node.item.response.declaration.Mapping;
import uk.ac.ed.ph.jqtiplus.node.item.response.declaration.ResponseDeclaration;
import uk.ac.ed.ph.jqtiplus.node.item.response.processing.ResponseCondition;
import uk.ac.ed.ph.jqtiplus.node.item.response.processing.ResponseElse;
import uk.ac.ed.ph.jqtiplus.node.item.response.processing.ResponseIf;
import uk.ac.ed.ph.jqtiplus.node.item.response.processing.ResponseProcessing;
import uk.ac.ed.ph.jqtiplus.node.item.response.processing.ResponseRule;
import uk.ac.ed.ph.jqtiplus.node.item.response.processing.SetOutcomeValue;
import uk.ac.ed.ph.jqtiplus.node.item.template.declaration.TemplateDeclaration;
import uk.ac.ed.ph.jqtiplus.node.outcome.declaration.OutcomeDeclaration;
import uk.ac.ed.ph.jqtiplus.node.shared.FieldValue;
import uk.ac.ed.ph.jqtiplus.node.shared.declaration.DefaultValue;
import uk.ac.ed.ph.jqtiplus.serialization.QtiSerializer;
import uk.ac.ed.ph.jqtiplus.types.ComplexReferenceIdentifier;
import uk.ac.ed.ph.jqtiplus.types.Identifier;
import uk.ac.ed.ph.jqtiplus.value.BaseType;
import uk.ac.ed.ph.jqtiplus.value.Cardinality;
import uk.ac.ed.ph.jqtiplus.value.IdentifierValue;
import uk.ac.ed.ph.jqtiplus.value.IntegerValue;
import uk.ac.ed.ph.jqtiplus.value.SingleValue;
import uk.ac.ed.ph.jqtiplus.value.StringValue;
import uk.ac.ed.ph.jqtiplus.value.Value;

/**
 * 
 * Initial date: 22 juin 2022<br>
 * @author srosse, stephane.rosse@frentix.com, http://www.frentix.com
 *
 */
public class InlineChoiceAssessmentItemBuilder extends AssessmentItemBuilder {

	private static final Logger log = Tracing.createLoggerFor(InlineChoiceAssessmentItemBuilder.class);
	
	private String question;
	private ScoreEvaluation scoreEvaluation;
	
	private List<GlobalInlineChoice> globalInlineChoices;
	private List<InlineChoiceInteractionEntry> inlineChoiceInteractions;
	
	public InlineChoiceAssessmentItemBuilder(String title, QtiSerializer qtiSerializer) {
		super(createAssessmentItem(title), qtiSerializer);
	}
	
	public InlineChoiceAssessmentItemBuilder(AssessmentItem assessmentItem, QtiSerializer qtiSerializer) {
		super(assessmentItem, qtiSerializer);
	}
	
	private static AssessmentItem createAssessmentItem(String title) {
		AssessmentItem assessmentItem = AssessmentItemFactory.createAssessmentItem(QTI21QuestionType.inlinechoice, title);
		
		//define the response
		Identifier responseDeclarationId = Identifier.assumedLegal("RESPONSE_1");
		Identifier correctResponseId = IdentifierGenerator.newAsIdentifier("inline");
		ResponseDeclaration responseDeclaration = createInlineChoiceResponseDeclaration(assessmentItem, responseDeclarationId,
				correctResponseId);
		assessmentItem.getNodeGroups().getResponseDeclarationGroup().getResponseDeclarations().add(responseDeclaration);

		//outcomes
		appendDefaultOutcomeDeclarations(assessmentItem, 1.0d);
		
		ItemBody itemBody = appendDefaultItemBody(assessmentItem);
		InlineChoiceInteraction interaction = appendInlineChoiceInteraction(itemBody, responseDeclarationId);
		appendInlineChoice(interaction, "Gap", correctResponseId);
		
		//response processing
		ResponseProcessing responseProcessing = createResponseProcessing(assessmentItem, responseDeclarationId);
		assessmentItem.getNodeGroups().getResponseProcessingGroup().setResponseProcessing(responseProcessing);
		return assessmentItem;
	}
	
	@Override
	protected void extract() {
		super.extract();
		extractTemplateDeclarationsForGlobal();
		extractQuestions();
		extractInteractions();
		extractInlineChoicesSettingsFromResponseDeclaration();
	}
	
	public void extractTemplateDeclarationsForGlobal() {
		globalInlineChoices = new ArrayList<>();
		
		List<TemplateDeclaration> templateDeclarations = assessmentItem.getTemplateDeclarations();
		for(TemplateDeclaration templateDeclaration:templateDeclarations) {
			String identifier = templateDeclaration.getIdentifier().toString();
			if(identifier.startsWith("global-")) {
				List<FieldValue> fValues = templateDeclaration.getDefaultValue().getFieldValues();
				for(FieldValue fValue:fValues) {
					String id = QtiNodesExtractor.extractId(fValue);
					SingleValue sValue = fValue.getSingleValue();
					if(sValue instanceof StringValue) {
						String val = ((StringValue)sValue).stringValue();
						globalInlineChoices.add(new GlobalInlineChoice(Identifier.assumedLegal(id), val));
					}
				}
			}
		}
	}
	
	public String extractQuestions() {
		try(StringOutput sb = new StringOutput()) {
			List<Block> blocks = assessmentItem.getItemBody().getBlocks();
			for(Block block:blocks) {
				serializeJqtiObject(block, sb);
				
			}
			question = sb.toString();
		} catch(IOException e) {
			log.error("", e);
		}
		return question;
	}
	
	public void extractInteractions() {
		inlineChoiceInteractions = new ArrayList<>();
		
		List<Interaction> interactions = assessmentItem.getItemBody().findInteractions();
		if(interactions != null) {
			for(Interaction interaction:interactions) {
				if(interaction instanceof InlineChoiceInteraction inlineChoiceInteraction) {
					inlineChoiceInteractions.add(new InlineChoiceInteractionEntry(inlineChoiceInteraction));
				}
			}
		}
	}
	
	public void extractInlineChoicesSettingsFromResponseDeclaration() {
		boolean hasMapping = false;
		List<Interaction> interactions = assessmentItem.getItemBody().findInteractions();
		for(Interaction interaction:interactions) {
			if(interaction instanceof InlineChoiceInteraction inlineChoiceInteraction && inlineChoiceInteraction.getResponseIdentifier() != null) {
				ResponseDeclaration responseDeclaration = assessmentItem.getResponseDeclaration(interaction.getResponseIdentifier());
				if(responseDeclaration != null && responseDeclaration.hasBaseType(BaseType.IDENTIFIER) && responseDeclaration.hasCardinality(Cardinality.SINGLE)) {
					InlineChoiceInteractionEntry inlineChoiceBlock = getInteractionEntry(inlineChoiceInteraction.getResponseIdentifier());
					extractInlineChoicesInteractionSettingsFromResponseDeclaration(responseDeclaration, inlineChoiceBlock);
					String marker = "responseIdentifier=\"" + interaction.getResponseIdentifier().toString() + "\"";
					if(inlineChoiceBlock.getCorrectResponseId() != null && inlineChoiceBlock.getSolution() != null) {
						String solution = inlineChoiceBlock.getSolution();
						question = question.replace(marker, marker + " data-qti-solution=\"" + escapeForDataQtiSolution(solution) + "\"");
					}
					
					hasMapping |= inlineChoiceBlock.hasScores();
				}
			}
		}
		
		if(hasMapping) {
			scoreEvaluation = ScoreEvaluation.perAnswer;
		} else if(QtiNodesExtractor.hasNegativePointSystem(assessmentItem)) {
			scoreEvaluation = ScoreEvaluation.negativePointSystem;
		} else {
			scoreEvaluation = ScoreEvaluation.allCorrectAnswers;
		}
	}
	
	public static void extractInlineChoicesInteractionSettingsFromResponseDeclaration(ResponseDeclaration responseDeclaration,
			InlineChoiceInteractionEntry inlineChoiceBlock) {
		CorrectResponse correctResponse = responseDeclaration.getCorrectResponse();
		if(correctResponse != null) {
			Value value = FieldValue.computeValue(Cardinality.SINGLE, correctResponse.getFieldValues());
			if(value instanceof IdentifierValue identifierValue) {
				inlineChoiceBlock.setCorrectResponseId(identifierValue.identifierValue());
			}
		}
		
		Mapping mapping = responseDeclaration.getMapping();
		if(mapping != null) {
			List<MapEntry> mapEntries = mapping.getMapEntries();
			for(MapEntry mapEntry:mapEntries) {
				SingleValue iValue = mapEntry.getMapKey();
				if(iValue instanceof IdentifierValue) {
					Identifier identifier = ((IdentifierValue)iValue).identifierValue();
					inlineChoiceBlock.putScore(identifier, mapEntry.getMappedValue());
				}	
			}
		}
	}
	
	public Identifier generateResponseIdentifier() {
		return IdentifierGenerator.newAsIdentifier("inline");
	}
	
	public Identifier generateIdentifier(Identifier globalChoice) {
		String choiceIdentifier = globalChoice.toString() + "-" + CodeHelper.getRAMUniqueID();
		return Identifier.assumedLegal(choiceIdentifier);
	}
	
	public List<InlineChoiceInteractionEntry> getInteractions() {
		return new ArrayList<>(inlineChoiceInteractions);
	}
	
	public InlineChoiceInteractionEntry getInteractionEntry(Identifier responseIdentifier) {
		for(InlineChoiceInteractionEntry interaction:inlineChoiceInteractions) {
			if(responseIdentifier.equals(interaction.getResponseIdentifier())) {
				return interaction;
			}
		}
		return null;
	}
	
	public InlineChoiceInteractionEntry getInteractionEntry(String responseIdentifier) {
		return getInteractionEntry(Identifier.assumedLegal(responseIdentifier));
	}
	
	public InlineChoiceInteractionEntry createInteraction(String responseIdentifier) {
		Identifier responseIdent = Identifier.parseString(responseIdentifier);
		InlineChoiceInteractionEntry choiceBlock = new InlineChoiceInteractionEntry(responseIdent);
		inlineChoiceInteractions.add(choiceBlock);
		return choiceBlock;
	}
	
	public void removeInteraction(InlineChoiceInteractionEntry interaction) {
		inlineChoiceInteractions.remove(interaction);
	}
	
	public List<GlobalInlineChoice> getGlobalInlineChoices() {
		return globalInlineChoices;
	}
	
	public void setGlobalInlineChoices(List<GlobalInlineChoice> globalChoices) {
		globalInlineChoices = new ArrayList<>(globalChoices);
	}
	
	private GlobalInlineChoice getGlobalInlineChoice(Identifier inlineChoiceId) {
		String identifier = inlineChoiceId.toString();
		
		for(GlobalInlineChoice globalInlineChoice:globalInlineChoices) {
			String globalId = globalInlineChoice.getIdentifier().toString();	
			if(identifier.startsWith(globalId)) {
				return globalInlineChoice;
			}
		}
		return null;
	}
	
	private GlobalInlineChoice getGlobalInlineChoiceByText(String text) {
		if(text == null) return null;

		for(GlobalInlineChoice globalInlineChoice:globalInlineChoices) {
			String globalText = globalInlineChoice.getText();
			if(text.equals(globalText)) {
				return globalInlineChoice;
			}
		}
		return null;
	}

	public ScoreEvaluation getScoreEvaluationMode() {
		return scoreEvaluation;
	}

	public void setScoreEvaluationMode(ScoreEvaluation scoreEvaluation) {
		this.scoreEvaluation = scoreEvaluation;
	}

	@Override
	public QTI21QuestionType getQuestionType() {
		return QTI21QuestionType.inlinechoice;
	}

	@Override
	public String getQuestion() {
		return question;
	}

	@Override
	public void setQuestion(String html) {
		this.question = html;
	}

	@Override
	protected void buildItemBody() {
		//remove current blocks
		List<Block> blocks = assessmentItem.getItemBody().getBlocks();
		blocks.clear();

		//add question
		getHtmlHelper().appendHtml(assessmentItem.getItemBody(), question);
		
		List<Interaction> interactions = assessmentItem.getItemBody().findInteractions();
		for(Interaction interaction:interactions) {
			if(interaction instanceof InlineChoiceInteraction) {
				buildInlineChoiceInteraction((InlineChoiceInteraction)interaction);
			}
		}
	}
	
	private void buildInlineChoiceInteraction(InlineChoiceInteraction inlineChoiceInteraction) {
		Identifier responseIdentifier = inlineChoiceInteraction.getResponseIdentifier();
		InlineChoiceInteractionEntry inlineChoiceInteractionEntry = inlineChoiceInteractions.stream()
			.filter(block -> responseIdentifier.equals(block.getResponseIdentifier()))
			.findFirst().orElse(null);
		if(inlineChoiceInteractionEntry != null) {
			inlineChoiceInteraction.setShuffle(inlineChoiceInteractionEntry.isShuffle());
			inlineChoiceInteraction.getInlineChoices().clear();
			Set<GlobalInlineChoice> usedGlobalInlineChoices = new HashSet<>();
			
			List<InlineChoice> inlineChoices = inlineChoiceInteractionEntry.getInlineChoices();
			for(InlineChoice inlineChoice:inlineChoices) {
				Identifier choiceIdentifier = inlineChoice.getIdentifier();
				InlineChoice copy = new InlineChoice(inlineChoiceInteraction);
				copy.setIdentifier(choiceIdentifier);
				
				String text;
				GlobalInlineChoice globalInlineChoice = getGlobalInlineChoice(inlineChoice.getIdentifier());
				if(globalInlineChoice != null) {
					text = globalInlineChoice.getText();
					usedGlobalInlineChoices.add(globalInlineChoice);
				} else {
					text = getText(inlineChoice);
				}
				copy.getTextOrVariables().add(new TextRun(copy, text));
				inlineChoiceInteraction.getInlineChoices().add(copy);
			}
			
			List<GlobalInlineChoice> missingGlobalInlineChoices = new ArrayList<>(globalInlineChoices);
			missingGlobalInlineChoices.removeAll(usedGlobalInlineChoices);
			
			for(GlobalInlineChoice missingGlobalInlineChoice:missingGlobalInlineChoices ) {
				InlineChoice copy = new InlineChoice(inlineChoiceInteraction);
				Identifier choiceIdentifier = generateIdentifier(missingGlobalInlineChoice.getIdentifier());
				copy.setIdentifier(choiceIdentifier);
				copy.getTextOrVariables().add(new TextRun(copy, missingGlobalInlineChoice.getText()));
				inlineChoiceInteraction.getInlineChoices().add(copy);
			}
		}
	}
	
	public static InlineChoice cloneInlineChoice(Interaction interaction, InlineChoice inlineChoice) {
		InlineChoice copy = new InlineChoice(interaction);
		copy.setIdentifier(inlineChoice.getIdentifier());
		String text = getText(inlineChoice);
		copy.getTextOrVariables().add(new TextRun(copy, text));
		return copy;
	}

	@Override
	protected void buildResponseAndOutcomeDeclarations() {
		List<ResponseDeclaration> responseDeclarations = assessmentItem.getResponseDeclarations();
		responseDeclarations.clear();
		
		/*
		<responseDeclaration identifier="RESPONSE_1" cardinality="single" baseType="identifier">
			<correctResponse>
				<value>Inline</value>
			</correctResponse>
			<mapping defaultValue="0">
				<mapEntry mapKey="inline" mappedValue="2" />
				<mapEntry mapKey="inline1" mappedValue="2" />
				<mapEntry mapKey="inline2" mappedValue="1" />
			</mapping>
		</responseDeclaration>
		*/
		List<InlineChoiceInteraction> interactions = getInlineChoiceInteractionsFromBody();
		for(InlineChoiceInteraction inlineChoiceInteraction:interactions) {
			InlineChoiceInteractionEntry inlineChoiceInteractionEntry = getInteractionEntry(inlineChoiceInteraction.getResponseIdentifier());
			if(inlineChoiceInteractionEntry != null
					&& inlineChoiceInteractionEntry.getResponseIdentifier() != null
					&& inlineChoiceInteractionEntry.getCorrectResponseId() != null) {
				ResponseDeclaration responseDeclaration = createInlineChoiceResponseDeclaration(assessmentItem,
						inlineChoiceInteractionEntry.getResponseIdentifier(), inlineChoiceInteractionEntry.getCorrectResponseId());
				responseDeclarations.add(responseDeclaration);
				
				if(scoreEvaluation == ScoreEvaluation.perAnswer) {
					Map<Identifier,Double> scoreMap = inlineChoiceInteractionEntry.getScores();
					appendMapping(responseDeclaration, scoreMap);
				}
			}
		}
		
		List<TemplateDeclaration> templateDeclarations = assessmentItem.getTemplateDeclarations();
		templateDeclarations.clear();
		if(!globalInlineChoices.isEmpty()) {
			buildTemplateDeclaration("global-inline-choices-1", globalInlineChoices, templateDeclarations);
		}
	}
	
	private void buildTemplateDeclaration(String identifier, List<GlobalInlineChoice> choices, List<TemplateDeclaration> templateDeclarations) {
		TemplateDeclaration templateDeclaration = new TemplateDeclaration(assessmentItem);
		templateDeclaration.setIdentifier(Identifier.assumedLegal(identifier));
		templateDeclaration.setCardinality(Cardinality.MULTIPLE);
		templateDeclaration.setBaseType(BaseType.STRING);
		templateDeclarations.add(templateDeclaration);
		
		DefaultValue defaultValue = new DefaultValue(templateDeclaration);
		templateDeclaration.setDefaultValue(defaultValue);
		
		List<FieldValue> fValues = defaultValue.getFieldValues();
		for(GlobalInlineChoice choice:choices) {
			FieldValue fieldVal = new FieldValue(defaultValue, new StringValue(choice.getText()));
			ForeignAttribute idAttr = new ForeignAttribute(fieldVal, "id", "");
			idAttr.setValue(choice.getIdentifier().toString());
			fieldVal.getAttributes().add(idAttr);
			fValues.add(fieldVal);
		}
	}

	@Override
	protected void buildMainScoreRule(List<OutcomeDeclaration> outcomeDeclarations, List<ResponseRule> responseRules) {
		ensureFeedbackBasicOutcomeDeclaration();
		if(scoreEvaluation == ScoreEvaluation.perAnswer) {
			buildMainScoreRulePerAnswer(outcomeDeclarations, responseRules);
		} else if(scoreEvaluation == ScoreEvaluation.negativePointSystem) {
			buildMainScoreRuleNegativePointSystem(outcomeDeclarations, responseRules);
		} else {
			buildMainScoreRuleAllCorrectAnswers(responseRules);
		}
	}
	
	private List<InlineChoiceInteraction> getInlineChoiceInteractionsFromBody() {
		List<Interaction> interactions = assessmentItem.getItemBody().findInteractions();
		return interactions.stream()
				.filter(InlineChoiceInteraction.class::isInstance)
				.map(InlineChoiceInteraction.class::cast)
				.collect(Collectors.toList());
	}
	
	@Override
	protected void buildModalFeedbacksAndHints(List<OutcomeDeclaration> outcomeDeclarations, List<ResponseRule> responseRules) {
		if((correctFeedback != null || incorrectFeedback != null) && scoreEvaluation == ScoreEvaluation.perAnswer) {
			ResponseCondition responseCondition = AssessmentItemFactory.createModalFeedbackResponseConditionByScore(assessmentItem.getResponseProcessing());
			responseRules.add(responseCondition);
		}

		super.buildModalFeedbacksAndHints(outcomeDeclarations, responseRules);
	}
	
	private void buildMainScoreRuleNegativePointSystem(List<OutcomeDeclaration> outcomeDeclarations, List<ResponseRule> responseRules) {
		outcomeDeclarations.add(AssessmentItemFactory.createNumCorrectOutcomeDelcarationForNPS(assessmentItem));
		outcomeDeclarations.add(AssessmentItemFactory.createNumIncorrectOutcomeDelcarationForNPS(assessmentItem));
		
		List<InlineChoiceInteraction> entries = getInlineChoiceInteractionsFromBody();
		int count = 0;
		int numOfChoices = entries.size();
		for(int i=0; i<numOfChoices; i++) {
			ResponseCondition rule = new ResponseCondition(assessmentItem.getResponseProcessing());
			responseRules.add(count++, rule);
			ResponseIf responseIf = new ResponseIf(rule);
			rule.setResponseIf(responseIf);
			
			InlineChoiceInteraction inlineChoiceEntry = entries.get(i);
			
			{// Response match correct answer
				ComplexReferenceIdentifier responseIdentifier = ComplexReferenceIdentifier
						.assumedLegal(inlineChoiceEntry.getResponseIdentifier().toString());
				
				Match match = new Match(responseIf);
				responseIf.getExpressions().add(match);
					
				Variable variable = new Variable(match);
				variable.setIdentifier(responseIdentifier);
				match.getExpressions().add(variable);
					
				Correct correct = new Correct(match);
				correct.setIdentifier(responseIdentifier);
				match.getExpressions().add(correct);
			}

			/*
			<setOutcomeValue identifier="NPS_NUMCORRECT">
          		<sum>
            		<variable identifier="NPS_NUMCORRECT" />
            		<baseValue baseType="integer">1</baseValue>
				</sum>
			</setOutcomeValue>
			*/
			{
				SetOutcomeValue setOutcomeValue = new SetOutcomeValue(responseIf);
				responseIf.getResponseRules().add(setOutcomeValue);
				setOutcomeValue.setIdentifier(QTI21Constants.NPS_NUMCORRECT_IDENTIFIER);
				
				Sum sum = new Sum(setOutcomeValue);
				setOutcomeValue.getExpressions().add(sum);
				
				Variable correctVariable = new Variable(sum);
				sum.getExpressions().add(correctVariable);
				correctVariable.setIdentifier(QTI21Constants.NPS_NUMCORRECT_CLX_IDENTIFIER);
				
				BaseValue baseValue = new BaseValue(sum);
				sum.getExpressions().add(baseValue);
				baseValue.setBaseTypeAttrValue(BaseType.INTEGER);
				baseValue.setSingleValue(new IntegerValue(1));
			}
		}
		
		// Calculate incorrect
		SetOutcomeValue setIncorrectOutcomeValue = AssessmentItemFactory
				.createNPSNumOfIncorrect(assessmentItem.getResponseProcessing(), numOfChoices);
		responseRules.add(count++, setIncorrectOutcomeValue);
		
		// Calculate score
		SetOutcomeValue setScoreOutcomeValue = AssessmentItemFactory
				.createNPSSetOutcomeValueForFIB(assessmentItem.getResponseProcessing(), numOfChoices);
		responseRules.add(count++, setScoreOutcomeValue);

		// Feedback
		ResponseCondition rule = AssessmentItemFactory
				.createNPSResponseConditionFeedbackWithNumOfCorrect(assessmentItem.getResponseProcessing(), numOfChoices);
		responseRules.add(count++, rule);
	}
	
	private void buildMainScoreRulePerAnswer(List<OutcomeDeclaration> outcomeDeclarations, List<ResponseRule> responseRules) {
		/*
		<setOutcomeValue identifier="SCORE_RESPONSE_1">
			<mapResponse identifier="RESPONSE_1" />
		</setOutcomeValue>
		*/
		
		/*
		<responseCondition>
			<responseIf>
				<equal toleranceMode="absolute" tolerance="2.0 2.0" includeLowerBound="true" includeUpperBound="true">
					<variable identifier="RESPONSE_3"/>
					<correct identifier="RESPONSE_3"/>
				</equal>
				<setOutcomeValue identifier="SCORE_RESPONSE_3">
					<baseValue baseType="float">3.0</baseValue>
				</setOutcomeValue>
			</responseIf>
	    </responseCondition>
		 */

		int count = 0;
		List<InlineChoiceInteraction> interactions = getInlineChoiceInteractionsFromBody();
		for(count = 0; count <interactions.size(); count++) {
			InlineChoiceInteraction inlineChoiceInteractionEntry = interactions.get(count);
			String scoreIdentifier = "SCORE_" + inlineChoiceInteractionEntry.getResponseIdentifier().toString();
			buildScoreRulePerAnswer(count, inlineChoiceInteractionEntry, Identifier.parseString(scoreIdentifier), responseRules);
		}

		/*
		<setOutcomeValue identifier="SCORE">
			<sum>
				<variable identifier="SCORE_RESPONSE_1" />
				<variable identifier="MINSCORE_RESPONSE_1" />
				<variable identifier="SCORE_RESPONSE_2" />
				<variable identifier="MINSCORE_RESPONSE_2" />
			</sum>
		</setOutcomeValue>
		*/
		{
			SetOutcomeValue scoreOutcome = new SetOutcomeValue(assessmentItem.getResponseProcessing());
			scoreOutcome.setIdentifier(QTI21Constants.SCORE_IDENTIFIER);
			responseRules.add(count++, scoreOutcome);
			
			Sum sum = new Sum(scoreOutcome);
			scoreOutcome.setExpression(sum);
			
			for(InlineChoiceInteraction inlineChoiceInteraction:interactions) {
				
				{//variable score
					Variable scoreVariable = new Variable(sum);
					sum.getExpressions().add(scoreVariable);
					String scoreIdentifier = "SCORE_" + inlineChoiceInteraction.getResponseIdentifier().toString();
					scoreVariable.setIdentifier(ComplexReferenceIdentifier.parseString(scoreIdentifier));
					
					//create associated outcomeDeclaration
					OutcomeDeclaration modalOutcomeDeclaration = AssessmentItemFactory
							.createOutcomeDeclarationForScoreResponse(assessmentItem, scoreIdentifier);
					outcomeDeclarations.add(modalOutcomeDeclaration);
				}
				
				{//variable minscore
					Variable minScoreVariable = new Variable(sum);
					sum.getExpressions().add(minScoreVariable);
					String scoreIdentifier = "MINSCORE_" + inlineChoiceInteraction.getResponseIdentifier().toString();
					minScoreVariable.setIdentifier(ComplexReferenceIdentifier.parseString(scoreIdentifier));
					
					//create associated outcomeDeclaration
					OutcomeDeclaration modalOutcomeDeclaration = AssessmentItemFactory
							.createOutcomeDeclarationForScoreResponse(assessmentItem, scoreIdentifier);
					outcomeDeclarations.add(modalOutcomeDeclaration);
				}
			}
		}
		
		if(correctFeedback != null || incorrectFeedback != null) {
			SetOutcomeValue incorrectOutcomeValue = new SetOutcomeValue(assessmentItem.getResponseProcessing());
			incorrectOutcomeValue.setIdentifier(QTI21Constants.FEEDBACKBASIC_IDENTIFIER);
			
			BaseValue correctValue = new BaseValue(incorrectOutcomeValue);
			correctValue.setBaseTypeAttrValue(BaseType.IDENTIFIER);
			correctValue.setSingleValue(QTI21Constants.INCORRECT_IDENTIFIER_VALUE);
			incorrectOutcomeValue.setExpression(correctValue);
			
			responseRules.add(count++, incorrectOutcomeValue);
		}	
	}
	
	/**
	 * Outcome map response.
	 * 
	 * @param count Current position of the rule
	 * @param entry The text entry
	 * @param scoreIdentifier The identifier of the score
	 * @param responseRules The list of response rules
	 */
	private void buildScoreRulePerAnswer(int count, InlineChoiceInteraction entry, Identifier scoreIdentifier,
			 List<ResponseRule> responseRules) {
		SetOutcomeValue mapOutcomeValue = new SetOutcomeValue(assessmentItem.getResponseProcessing());
		responseRules.add(count, mapOutcomeValue);
		mapOutcomeValue.setIdentifier(scoreIdentifier);
		
		MapResponse mapResponse = new MapResponse(mapOutcomeValue);
		mapResponse.setIdentifier(entry.getResponseIdentifier());
		mapOutcomeValue.setExpression(mapResponse);
	}
	
	private void buildMainScoreRuleAllCorrectAnswers(List<ResponseRule> responseRules) {
		/*
		<responseCondition>
			<responseIf>
				<and>
					<match>
						<variable identifier="RESPONSE_1" />
						<correct identifier="RESPONSE_1" />
					</match>
				</and>
				<setOutcomeValue identifier="SCORE">
					<sum>
						<variable identifier="SCORE" />
						<variable identifier="MAXSCORE" />
					</sum>
				</setOutcomeValue>
				<setOutcomeValue identifier="FEEDBACKBASIC">
					<baseValue baseType="identifier">
						incorrect
					</baseValue>
				</setOutcomeValue>
			</responseIf>
		</responseCondition>
		*/

		// add condition
		ResponseCondition rule = new ResponseCondition(assessmentItem.getResponseProcessing());
		responseRules.add(0, rule);

		{// match all
			ResponseIf responseIf = new ResponseIf(rule);
			rule.setResponseIf(responseIf);
			
			And and = new And(responseIf);
			responseIf.setExpression(and);
			
			List<InlineChoiceInteraction> interactions = getInlineChoiceInteractionsFromBody();
			for(InlineChoiceInteraction inlineChoiceEntry:interactions) {
				ComplexReferenceIdentifier responseIdentifier = ComplexReferenceIdentifier
						.assumedLegal(inlineChoiceEntry.getResponseIdentifier().toString());
				
				Match match = new Match(and);
				and.getExpressions().add(match);
					
				Variable variable = new Variable(match);
				variable.setIdentifier(responseIdentifier);
				match.getExpressions().add(variable);
					
				Correct correct = new Correct(match);
				correct.setIdentifier(responseIdentifier);
				match.getExpressions().add(correct);
			}
			
			{// outcome max score -> score
				SetOutcomeValue scoreOutcomeValue = new SetOutcomeValue(responseIf);
				scoreOutcomeValue.setIdentifier(QTI21Constants.SCORE_IDENTIFIER);
				responseIf.getResponseRules().add(scoreOutcomeValue);
				
				Sum sum = new Sum(scoreOutcomeValue);
				scoreOutcomeValue.getExpressions().add(sum);
				
				Variable scoreVar = new Variable(sum);
				scoreVar.setIdentifier(QTI21Constants.SCORE_CLX_IDENTIFIER);
				sum.getExpressions().add(scoreVar);
				
				Variable maxScoreVar = new Variable(sum);
				maxScoreVar.setIdentifier(QTI21Constants.MAXSCORE_CLX_IDENTIFIER);
				sum.getExpressions().add(maxScoreVar);
			}
			
			{//outcome feedback
				SetOutcomeValue correctOutcomeValue = new SetOutcomeValue(responseIf);
				correctOutcomeValue.setIdentifier(QTI21Constants.FEEDBACKBASIC_IDENTIFIER);
				responseIf.getResponseRules().add(correctOutcomeValue);
				
				BaseValue correctValue = new BaseValue(correctOutcomeValue);
				correctValue.setBaseTypeAttrValue(BaseType.IDENTIFIER);
				correctValue.setSingleValue(QTI21Constants.CORRECT_IDENTIFIER_VALUE);
				correctOutcomeValue.setExpression(correctValue);
			}
		}
		
		{// else feedback incorrect
			ResponseElse responseElse = new ResponseElse(rule);
			rule.setResponseElse(responseElse);
			
			{//outcome feedback
				SetOutcomeValue correctOutcomeValue = new SetOutcomeValue(responseElse);
				correctOutcomeValue.setIdentifier(QTI21Constants.FEEDBACKBASIC_IDENTIFIER);
				responseElse.getResponseRules().add(correctOutcomeValue);
				
				BaseValue correctValue = new BaseValue(correctOutcomeValue);
				correctValue.setBaseTypeAttrValue(BaseType.IDENTIFIER);
				correctValue.setSingleValue(QTI21Constants.INCORRECT_IDENTIFIER_VALUE);
				correctOutcomeValue.setExpression(correctValue);
			}
		}
	}
	
	@Override
	public void postImportProcessing() {
		super.postImportProcessing();
		postImportGlobalChoiceProcessing();
	}

	private void postImportGlobalChoiceProcessing() {
		List<InlineChoiceInteractionEntry> interactions = getInteractions();
		if(interactions.size() <= 1) return;
		
		List<String> referenceSet = null;
		for(InlineChoiceInteractionEntry interaction:interactions) {
			List<InlineChoice> inlineChoices = interaction.getInlineChoices();
			List<String> choiceSet = inlineChoices.stream()
					.map(InlineChoiceAssessmentItemBuilder::getText)
					.collect(Collectors.toList());
			
			if(referenceSet == null) {
				referenceSet = choiceSet;
			} else if(!referenceSet.containsAll(choiceSet) || !choiceSet.containsAll(referenceSet)) {
				return;
			}	
		}
		
		if(referenceSet != null) {
			// Make reference set global
			for(int i=0; i<referenceSet.size(); i++) {
				Identifier id = IdentifierGenerator.newAsIdentifier("global-1-");
				GlobalInlineChoice globalInlineChoice = new GlobalInlineChoice(id, referenceSet.get(i));
				globalInlineChoices.add(globalInlineChoice);
			}
			
			// Mutate the choice identifier and correct response identifier with global ones
			for(InlineChoiceInteractionEntry interaction:interactions) {
				Identifier correctResponse = interaction.getCorrectResponseId();
				List<InlineChoice> inlineChoices = interaction.getInlineChoices();
				for(InlineChoice inlineChoice:inlineChoices) {
					final String text = getText(inlineChoice);
					final Identifier identifier = inlineChoice.getIdentifier();
					final GlobalInlineChoice gChoice = getGlobalInlineChoiceByText(text);
					if(gChoice != null) {
						Identifier newIdentifier = generateIdentifier(gChoice.getIdentifier());
						if(correctResponse != null && correctResponse.equals(identifier)) {
							interaction.setCorrectResponseId(newIdentifier);
						}
						Double score = interaction.getScore(inlineChoice.getIdentifier());
						if(score != null) {
							interaction.putScore(inlineChoice.getIdentifier(), null);
							interaction.putScore(newIdentifier, score);
						}
						inlineChoice.setIdentifier(newIdentifier);
					}
				}
			}
		}
	}
	
	public static String getText(InlineChoice inlineChoice) {
		StringBuilder textSolution = new StringBuilder();

		List<TextOrVariable> values = inlineChoice.getTextOrVariables();
		for(TextOrVariable value:values) {
			if(value instanceof TextRun) {
				String text = ((TextRun)value).getTextContent();
				if(StringHelper.containsNonWhitespace(text)) {
					textSolution.append(text);
				}
			}
		}

		return textSolution.toString();
	}
	
	public static class GlobalInlineChoice {
		
		private final Identifier identifier;
		private String text;
		
		public GlobalInlineChoice(Identifier identifier, String text) {
			this.identifier = identifier;
			this.text = text;
		}

		public Identifier getIdentifier() {
			return identifier;
		}

		public String getText() {
			return text;
		}

		public void setText(String text) {
			this.text = text;
		}

		@Override
		public int hashCode() {
			return identifier.hashCode();
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if(obj instanceof GlobalInlineChoice) {
				GlobalInlineChoice other = (GlobalInlineChoice) obj;
				return Objects.equals(identifier, other.identifier);
			}
			return false;
		}
	}

	public static class InlineChoiceInteractionEntry {
		
		private final InlineChoiceInteraction interaction;
		private final Identifier responseIdentifier;
		private final List<InlineChoice> inlineChoices;
		private final Map<Identifier,Double> scores = new HashMap<>();
		
		private Identifier correctResponseId;
		private boolean shuffle = true;
		
		public InlineChoiceInteractionEntry(InlineChoiceInteraction interaction) {
			this.interaction = interaction;
			responseIdentifier = interaction.getResponseIdentifier();
			inlineChoices = new ArrayList<>(interaction.getInlineChoices());
			shuffle = interaction.getShuffle();
		}
		
		public InlineChoiceInteractionEntry(Identifier responseIdentifier) {
			interaction = null;
			inlineChoices = new ArrayList<>();
			this.responseIdentifier = responseIdentifier;
		}
		
		public Identifier getResponseIdentifier() {
			return interaction == null ? responseIdentifier : interaction.getResponseIdentifier();
		}
		
		public Double getScore(Identifier identifier) {
			return scores.get(identifier);
		}
		
		public void putScore(Identifier identifier, Double score) {
			if(score != null) {
				scores.put(identifier, score);
			} else {
				scores.remove(identifier);
			}	
		}
		
		public Map<Identifier,Double> getScores() {
			Map<Identifier,Double> scoresMap = new HashMap<>();
			for(InlineChoice inlineChoice:inlineChoices) {
				Double score = scores.get(inlineChoice.getIdentifier());
				if(score == null) {
					score = Double.valueOf(0.0d);
				}
				scoresMap.put(inlineChoice.getIdentifier(), score);
			}
			return scoresMap;
		}
		
		public boolean hasScores() {
			return !scores.isEmpty();
		}
		
		public InlineChoiceInteraction getInteraction() {
			return interaction;
		}
		
		public List<InlineChoice> getInlineChoices() {
			return inlineChoices;
		}
		
		public InlineChoice getInlineChoice(Identifier identifier) {
			return inlineChoices.stream()
					.filter(choice -> identifier.equals(choice.getIdentifier()))
					.findFirst().orElse(null);
		}

		public boolean isShuffle() {
			return shuffle;
		}

		public void setShuffle(boolean shuffle) {
			this.shuffle = shuffle;
		}

		public Identifier getCorrectResponseId() {
			return correctResponseId;
		}

		public void setCorrectResponseId(Identifier correctResponseId) {
			this.correctResponseId = correctResponseId;
		}
		
		public String getSolution() {
			String textSolution = null;
			if(correctResponseId != null && interaction != null && interaction.getInlineChoices() != null) {
				for(InlineChoice inlineChoice:interaction.getInlineChoices()) {
					if(correctResponseId.equals(inlineChoice.getIdentifier())) {
						textSolution = getText(inlineChoice);
					}
				}
			}
			return textSolution;
		}

		@Override
		public int hashCode() {
			return Objects.hash(responseIdentifier);
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj instanceof InlineChoiceInteractionEntry) {
				InlineChoiceInteractionEntry other = (InlineChoiceInteractionEntry) obj;
				return responseIdentifier != null && Objects.equals(responseIdentifier, other.responseIdentifier);
			}
			return false;
		}
	}
}